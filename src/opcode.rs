use crate::{stack::Label, MemoryOperand, RefType, ValueType};

#[allow(non_camel_case_types)]
#[derive(Debug, PartialEq, Clone)]
#[repr(u16)]
pub enum Instruction {
    Unreachable = 0x00,
    Nop = 0x01,
    Block(Label) = 0x02,
    Loop(Label) = 0x03,
    If(Label) = 0x04,
    Else = 0x05,
    End = 0x0b,
    Branch(u32) = 0x0c,
    BranchIf(u32) = 0x0d,
    BranchTable(Vec<u32>, u32) = 0x0e,
    Return = 0x0f,
    Call(u32) = 0x10,
    CallIndirect(u32, u32) = 0x11,
    Drop = 0x1a,
    Select = 0x1b,
    SelectT(Vec<ValueType>) = 0x1c,
    LocalGet(u32) = 0x20,
    LocalSet(u32) = 0x21,
    LocalTee(u32) = 0x22,
    GlobalGet(u32) = 0x23,
    GlobalSet(u32) = 0x24,
    TableGet(u32) = 0x25,
    TableSet(u32) = 0x26,
    i32Load(MemoryOperand) = 0x28,
    i64Load(MemoryOperand) = 0x29,
    f32Load(MemoryOperand) = 0x2a,
    f64Load(MemoryOperand) = 0x2b,
    i32Load8Signed(MemoryOperand) = 0x2c,
    i32Load8Unsigned(MemoryOperand) = 0x2d,
    i32Load16Signed(MemoryOperand) = 0x2e,
    i32Load16Unsigned(MemoryOperand) = 0x2f,
    i64Load8Signed(MemoryOperand) = 0x30,
    i64Load8Unsigned(MemoryOperand) = 0x31,
    i64Load16Signed(MemoryOperand) = 0x32,
    i64Load16Unsigned(MemoryOperand) = 0x33,
    i64Load32Signed(MemoryOperand) = 0x34,
    i64Load32Unsigned(MemoryOperand) = 0x35,
    i32Store(MemoryOperand) = 0x36,
    i64Store(MemoryOperand) = 0x37,
    f32Store(MemoryOperand) = 0x38,
    f64Store(MemoryOperand) = 0x39,
    i32Store8(MemoryOperand) = 0x3a,
    i32Store16(MemoryOperand) = 0x3b,
    i64Store8(MemoryOperand) = 0x3c,
    i64Store16(MemoryOperand) = 0x3d,
    i64Store32(MemoryOperand) = 0x3e,
    MemorySize = 0x3f,
    MemoryGrow = 0x40,
    i32Const(i32) = 0x41,
    i64Const(i64) = 0x42,
    f32Const(f32) = 0x43,
    f64Const(f64) = 0x44,
    i32EqZero = 0x45,
    i32Eq = 0x46,
    i32Ne = 0x47,
    i32LtSigned = 0x48,
    i32LtUnsigned = 0x49,
    i32GtSigned = 0x4a,
    i32GtUnsigned = 0x4b,
    i32LeSigned = 0x4c,
    i32LeUnsigned = 0x4d,
    i32GeSigned = 0x4e,
    i32GeUnsigned = 0x4f,
    i64EqZero = 0x50,
    i64Eq = 0x51,
    i64Ne = 0x52,
    i64LtSigned = 0x53,
    i64LtUnsigned = 0x54,
    i64GtSigned = 0x55,
    i64GtUnsigned = 0x56,
    i64LeSigned = 0x57,
    i64LeUnsigned = 0x58,
    i64GeSigned = 0x59,
    i64GeUnsigned = 0x5a,
    f32Eq = 0x5b,
    f32Ne = 0x5c,
    f32Lt = 0x5d,
    f32Gt = 0x5e,
    f32Le = 0x5f,
    f32Ge = 0x60,
    f64Eq = 0x61,
    f64Ne = 0x62,
    f64Lt = 0x63,
    f64Gt = 0x64,
    f64Le = 0x65,
    f64Ge = 0x66,
    i32CountLeadingZeros = 0x67,
    i32CountTrailingZeros = 0x68,
    i32PopulationCount = 0x69,
    i32Add = 0x6a,
    i32Sub = 0x6b,
    i32Mul = 0x6c,
    i32SignedDiv = 0x6d,
    i32UnsignedDiv = 0x6e,
    i32SignedRem = 0x6f,
    i32UnsignedRem = 0x70,
    i32BitwiseAnd = 0x71,
    i32BitwiseOr = 0x72,
    i32BitwiseXor = 0x73,
    i32BitwiseShiftLeft = 0x74,
    i32SignedBitwiseShiftRight = 0x75,
    i32UnsignedBitwiseShiftRight = 0x76,
    i32RotateLeft = 0x77,
    i32RotateRight = 0x78,
    i64CountLeadingZeros = 0x79,
    i64CountTrailingZeros = 0x7a,
    i64PopulationCount = 0x7b,
    i64Add = 0x7c,
    i64Sub = 0x7d,
    i64Mul = 0x7e,
    i64SignedDiv = 0x7f,
    i64UnsignedDiv = 0x80,
    i64SignedRem = 0x81,
    i64UnsignedRem = 0x82,
    i64BitwiseAnd = 0x83,
    i64BitwiseOr = 0x84,
    i64BitwiseXor = 0x85,
    i64BitwiseShiftLeft = 0x86,
    i64SignedBitwiseShiftRight = 0x87,
    i64UnsignedBitwiseShiftRight = 0x88,
    i64RotateLeft = 0x89,
    i64RotateRight = 0x8a,
    f32Abs = 0x8b,
    f32Neg = 0x8c,
    f32Ceil = 0x8d,
    f32Floor = 0x8e,
    f32Trunc = 0x8f,
    f32Nearest = 0x90,
    f32Sqrt = 0x91,
    f32Add = 0x92,
    f32Sub = 0x93,
    f32Mul = 0x94,
    f32Div = 0x95,
    f32Min = 0x96,
    f32Max = 0x97,
    f32CopySign = 0x98,
    f64Abs = 0x99,
    f64Neg = 0x9a,
    f64Ceil = 0x9b,
    f64Floor = 0x9c,
    f64Trunc = 0x9d,
    f64Nearest = 0x9e,
    f64Sqrt = 0x9f,
    f64Add = 0xa0,
    f64Sub = 0xa1,
    f64Mul = 0xa2,
    f64Div = 0xa3,
    f64Min = 0xa4,
    f64Max = 0xa5,
    f64CopySign = 0xa6,
    i32WrapI64 = 0xa7,
    i32TruncF32Signed = 0xa8,
    i32TruncF32Unsigned = 0xa9,
    i32TruncF64Signed = 0xaa,
    i32TruncF64Unsigned = 0xab,
    i64Extendi32Signed = 0xac,
    i64Extendi32Unsigned = 0xad,
    i64TruncF32Signed = 0xae,
    i64TruncF32Unsigned = 0xaf,
    i64TruncF64Signed = 0xb0,
    i64TruncF64Unsigned = 0xb1,
    f32SignedConvertI32 = 0xb2,
    f32UnsignedConvertI32 = 0xb3,
    f32SignedConvertI64 = 0xb4,
    f32UnsignedConvertI64 = 0xb5,
    f32DemoteF64 = 0xb6,
    f64SignedConvertI32 = 0xb7,
    f64UnsignedConvertI32 = 0xb8,
    f64SignedConvertI64 = 0xb9,
    f64UnsignedConvertI64 = 0xba,
    f64PromoteF32 = 0xbb,
    i32ReinterpretF32 = 0xbc,
    i64ReinterpretF64 = 0xbd,
    f32ReinterpretI32 = 0xbe,
    f64ReinterpretI64 = 0xbf,
    i32Extend8Signed = 0xc0,
    i32Extend16Signed = 0xc1,
    i64Extend8Signed = 0xc2,
    i64Extend16Signed = 0xc3,
    i64Extend32Signed = 0xc4,
    RefNull(RefType) = 0xd0,
    RefIsNull = 0xd1,
    RefFunc(u32) = 0xd2,
    i32TruncSatf32Signed = 0xfc_00,
    i32TruncSatf32Unsigned = 0xfc_01,
    i32TruncSatf64Signed = 0xfc_02,
    i32TruncSatf64Unsigned = 0xfc_03,
    i64TruncSatf32Signed = 0xfc_04,
    i64TruncSatf32Unsigned = 0xfc_05,
    i64TruncSatf64Signed = 0xfc_06,
    i64TruncSatf64Unsigned = 0xfc_07,
    MemoryInit(u32) = 0xfc_08,
    DataDrop(u32) = 0xfc_09,
    MemoryCopy = 0xfc_0a,
    MemoryFill = 0xfc_0b,
    TableInit(u32, u32) = 0xfc_0c,
    ElemDrop(u32) = 0xfc_0d,
    TableCopy(u32, u32) = 0xfc_0e,
    TableGrow(u32) = 0xfc_0f,
    TableSize(u32) = 0xfc_10,
    TableFill(u32) = 0xfc_11,
}

impl Instruction {
    pub fn set_label_end(&mut self, end: usize) {
        match self {
            Self::Block(label) => label.continuation = end,
            Self::Loop(..) => {}
            // todo: handle else
            Self::If(label) => label.continuation = end,
            inst => panic!("{:?}", inst),
        };
    }
}
